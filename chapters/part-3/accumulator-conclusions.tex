\section{Conclusion}
\label{sec:accumulator-conclusions}


In this part of the study, we have designed and implemented the \textit{accumulator} concept for efficient transfers of sparse compressed Jacobian matrices between \acrshort{athlet} and \acrshort{nut}. The concept is rather simple and did not require drastic changes of the existing software design and architecture. In spite of simplicity, the concept allows to significantly reduce communication time i.e. by almost \textbf{60\%}. The overall performance gain comes from three different sources: 

\begin{enumerate}
	\item efficient utilization of interconnection
	\item reduced number of handshakes and, as a result, a reduced amount of \acrshort{nut} process synchronizations
	\item overlaps of communications with computations
\end{enumerate}

The study has shown that non-blocking data transfers are the main source of the performance gain. Efficient bandwidth utilization can additionally give \textbf{7-9\%} of improvement when applications work within the same compute-node.\\


One can experience slight slow-down from pure data accumulation in case of inter-node communication due to probable \acrshort{mpi} protocol switching. However, as it has been shown, it is always compensated by means of communication/computation overlaps.\\


The final tests have shown the concept does not give a considerable overall improvement because the computation part takes almost \textbf{99.8\%} of the total execution time of the corresponding part of the source code. However, results may be much better in case of multi-client operation of \acrshort{nut}, especially when clients are sharing common \acrshort{nut} processes; a reduced number of data transfers results in a reduced amount of handshakes which are always accompanied by the resource acquisition mechanism, described in Section \ref{sec:athlet-nut-coupling}. Unfortunately, it is difficult to design and prepare a set of valid tests to verify this statement. \\


By and large, verification of the modified code has not detected any deviations in numerical results. The new concept has always resulted in a slight overall performance gain. The study has also shown the main bottleneck is, indeed, the non-linear function evaluation.\\


It is worth mentioning that only the sequential \acrshort{athlet} code,  capable to run only in a single core, was available for this study. However, there exists a parallel version of \acrshort{athlet} multi-threaded with \acrshort{openmp}. Therefore, the results can be even better because of a reduced fraction of execution time spent on non-linear function evaluations. This fact also shows that performance tuning of \acrshort{athlet} is constantly in progress and is being done in parallel among several departments of \acrshort{grs}, covering different areas of the program source code.\\


